# -*- coding: utf-8 -*-
"""Multiple choice chatbot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bq9kaC7wXvTPXU7oV9Ob7CpBd2HkaAfb
"""

import pandas as pd

df=pd.read_csv("/content/Question Answer - Sheet1.csv")

rows_as_list = df.values.tolist()

print(rows_as_list)

questions=[]
for row in rows_as_list:
  questions.append(row[0])
  print(row[0])

print(questions)

for i in rows_as_list:
  for j in range(6):
    if(j==5):
      print("Answer:", i[j])
    else:
      print(i[j])

solutions=[]
for row in rows_as_list:
  solutions.append(row[5])
  print(row[5])
print(solutions)

total_score=0;
for i in range(len(rows_as_list)):
  for j in range(5):
    if(j==0):
      print("Question:", rows_as_list[i][j])
    else:
      print("Option ",j,":",rows_as_list[i][j])
  answer=int(input("Enter Option Number: "))
  if(rows_as_list[i][answer]==rows_as_list[i][5]):
    total_score+=1
    print("Correct Answer!")
  else:
    print("Incorrect!", rows_as_list[i][5]," is the right answer")
print(total_score," is your total score")

main = []
for i in range(len(rows_as_list)):
    temp = []
    options = []
    for j in range(len(rows_as_list[i])):
        if j == 0:
            temp.append(rows_as_list[i][0])  # First element is the pattern (question)
        else:
            options.append(rows_as_list[i][j])  # Rest are responses
    temp.append(options)  # Add responses list to temp
    main.append(temp)  # Add temp to main

# Prepare pairs for Chat
pairs = []
for i in range(len(main)):
    qna = []
    for j in range(len(main[i])):  # Changed to use main[i]
        qna.append(main[i][j])
    pairs.append(tuple(qna))
print(pairs)

import nltk
nltk.download('all')

import re







class Chat(object):
    def __init__(self, pairs, reflections={}):
        """
        Initialize the chatbot.  Pairs is a list of patterns and responses.  Each
        pattern is a regular expression matching the user's statement or question,
        e.g. r'I like (.*)'.  For each such pattern a list of possible responses
        is given, e.g. ['Why do you like %1', 'Did you ever dislike %1'].  Material
        which is matched by parenthesized sections of the patterns (e.g. .*) is mapped to
        the numbered positions in the responses, e.g. %1.

        :type pairs: list of tuple
        :param pairs: The patterns and responses
        :type reflections: dict
        :param reflections: A mapping between first and second person expressions
        :rtype: None
        """

        self._pairs = [(re.compile(x, re.IGNORECASE), y) for (x, y) in pairs]
        self._reflections = reflections
        self._regex = self._compile_reflections()

    def _compile_reflections(self):
        sorted_refl = sorted(self._reflections.keys(), key=len, reverse=True)
        return re.compile(
            r"\b({0})\b".format("|".join(map(re.escape, sorted_refl))), re.IGNORECASE
        )

    def _substitute(self, str):
        """
        Substitute words in the string, according to the specified reflections,
        e.g. "I'm" -> "you are"

        :type str: str
        :param str: The string to be mapped
        :rtype: str
        """

        return self._regex.sub(
            lambda mo: self._reflections[mo.string[mo.start() : mo.end()]], str.lower()
        )

    def _wildcards(self, response, match):
        pos = response.find('%')
        while pos >= 0:
            num = int(response[pos + 1 : pos + 2])
            response = (
                response[:pos]
                + self._substitute(match.group(num))
                + response[pos + 2 :]
            )
            pos = response.find('%')
        return response

    def respond(self, str):
        """
        Generate a response to the user input.

        :type str: str
        :param str: The string to be mapped
        :rtype: str
        """

        # check each pattern
        for (pattern, response) in self._pairs:
            match = pattern.match(str)

            # did the pattern match?
            if match:
                # print(match,response)
                # resp = random.choice(response)  # pick a random response
                # resp = self._wildcards(resp, match)  # process wildcards

                # # fix munged punctuation at the end
                # if resp[-2:] == '?.':
                #     resp = resp[:-2] + '.'
                # if resp[-2:] == '??':
                #     resp = resp[:-2] + '?'
                return response

    # Hold a conversation with a chatbot
    def converse(self,user, quit="quit"):
        user_input = ""
        user_input = quit
        try:
            user_input = user
        except EOFError:
            print(user_input)
        if user_input:
            while user_input[-1] in "!.":
                user_input = user_input[:-1]
            return(self.respond(user_input))




main = []
for i in range(len(rows_as_list)):
    temp = []
    options = []
    for j in range(len(rows_as_list[i])-1):
        if j == 0:
            temp.append(rows_as_list[i][0])  # First element is the pattern (question)
        else:
            options.append(rows_as_list[i][j])  # Rest are responses
    temp.append(options)  # Add responses list to temp
    main.append(temp)  # Add temp to main

# Prepare pairs for Chat
pairs = []
for i in range(len(main)):
    qna = []
    for j in range(len(main[i])):  # Changed to use main[i]
        qna.append(main[i][j])
    pairs.append(qna)
# print(pairs)  # Ensure each pair is a tuple (pattern, responses)

# Function to handle chat response
def chatty(query):
    chat = Chat(pairs, reflections)
    values = chat.respond(query)


      # Use respond() instead of converse()
    return values
for i in pairs:
    print(i)
# Conversation loop
for i in range(len(questions)):
    print(questions[i])

    response = chatty(questions[i])
    if response:
        for j in response:
            print(j)
    option=int(input("Give option number: "))
    if(rows_as_list[i][option]==rows_as_list[i][5]):

       print("Correct Answer!")
    else:
       print("Incorrect!", rows_as_list[i][5]," is the right answer")