# -*- coding: utf-8 -*-
"""NLP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XyJ_y9NKQppnbMV1d7AITA7LDd61rGiX
"""

import nltk
nltk.download('all')
#

#tokenisation (converting sentences to words and paragraphs to sentences)

from nltk import word_tokenize,sent_tokenize
word="hi my name is mishty and im learning ML"
sentence="hello. i wanna see how this would work? expected output in mind?"
print(word_tokenize(word))
print(word_tokenize(sentence))# word tokenize works with spaces
print(sent_tokenize(sentence))# works accroding to punctuation

#canonicalistion: figuring out the base word for the words used in a sentence
#two wyas of canonicalistaion stemming and lemmatization

#Stemming generates the base word from the inflected word by removing the affixes of the word. It has a set of pre-defined rules that govern the dropping of these affixes. It must be noted that stemmers might not always result in semantically meaningful base words.  Stemmers are faster and computationally less expensive than lemmatizers.

from nltk.stem import PorterStemmer

stemmer=PorterStemmer()
stemmer.stem("playing")

"""Lemmatization
Lemmatization involves grouping together the inflected forms of the same word. This way, we can reach out to the base form of any word which will be meaningful in nature. The base from here is called the Lemma.

Lemmatizers are slower and computationally more expensive than stemmers.
"""

from nltk.stem import WordNetLemmatizer

lemmatizer = WordNetLemmatizer()
print(lemmatizer.lemmatize("plays", 'v'))
print(lemmatizer.lemmatize("played", 'v'))
print(lemmatizer.lemmatize("play", 'v'))
print(lemmatizer.lemmatize("playing", 'v'))

from nltk import pos_tag
from nltk import word_tokenize

text = "hello. i wanna see how this would work? expected output in mind?"
tokenized_text = word_tokenize(text)
tags = tokens_tag = pos_tag(tokenized_text)
tags

from nltk.chat.util import Chat, reflections

'''# Define pattern-response pairs
pairs = [
    [r"hi|hey|hello", ["Hello!", "Hey there!"]],
    [r"my name is (.*)", ["Hello %1, How are you today?"]],
    [r"quit|bye", ["Bye! Take care.", "It was nice talking to you. See you soon!"]],
]

def chat():
    print("Hi! I am a chatbot created by Analytics Vidhya for your service")
    chat_bot = Chat(pairs, reflections)  # Create an instance of Chat
    while True:
        user_input = input("You: ")
        response = chat_bot.respond(user_input)  # Use the instance to get a response
        print("Alexa:", response)
        if user_input.lower() == "quit" or user_input.lower()=='bye':
            print("Alexa: Goodbye!")
            break

# Initiate the conversation
if __name__ == "__main__":
    chat()'''

'''from nltk.chat.util import Chat,reflections
pairs=[[r"Hi I am (.*)",["Hi %1, I am Alexa"]],[r"quit",["byeeee"]],[r"bye",["bye"]]]
def chat():
  print("Hi I am Alexa")
  chat= Chat(pairs, reflections)
  chat.converse()
if __name__ == "__main__":
    chat()'''

import re
import random

reflections = {
    "i am": "you are",
    "i was": "you were",
    "i": "you",
    "i'm": "you are",
    "i'd": "you would",
    "i've": "you have",
    "i'll": "you will",
    "my": "your",
    "you are": "I am",
    "you were": "I was",
    "you've": "I have",
    "you'll": "I will",
    "your": "my",
    "yours": "mine",
    "you": "me",
    "me": "you",
}

class Chat(object):
    def __init__(self, pairs, reflections={}):


        self._pairs = [(re.compile(x, re.IGNORECASE), y) for (x, y) in pairs]# for key value pairs, the case of keys has been ignored
        self._reflections = reflections
        self._regex = self._compile_reflections()#samjho

    def _compile_reflections(self):
        sorted_refl = sorted(self._reflections.keys(), key=len, reverse=True)
        return re.compile(
            r"\b({0})\b".format("|".join(map(re.escape, sorted_refl))), re.IGNORECASE
        )
    def _substitute(self, str):
        """
        Substitute words in the string, according to the specified reflections,
        e.g. "I'm" -> "you are"

        :type str: str
        :param str: The string to be mapped
        :rtype: str
        """

        return self._regex.sub(
            lambda mo: self._reflections[mo.string[mo.start() : mo.end()]], str.lower()
        )
    def _wildcards(self, response, match):
        pos = response.find('%')
        while pos >= 0:
            num = int(response[pos + 1 : pos + 2])
            response = (
                response[:pos]
                + self._substitute(match.group(num))
                + response[pos + 2 :]
            )
            pos = response.find('%')
        return response

    def respond(self, str):
        """
        Generate a response to the user input.

        :type str: str
        :param str: The string to be mapped
        :rtype: str
        """

        # check each pattern
        for (pattern, response) in self._pairs:
            match = pattern.match(str)

            # did the pattern match?
            if match:
                resp = random.choice(response)  # pick a random response
                resp = self._wildcards(resp, match)  # process wildcards

                # fix munged punctuation at the end
                if resp[-2:] == '?.':
                    resp = resp[:-2] + '.'
                if resp[-2:] == '??':
                    resp = resp[:-2] + '?'
                return resp
    def converse(self, user_input, quit="quit"):
      """
      Process user input, generate a response, and handle trailing punctuation.

      :type user_input: str
      :param user_input: The input from the user
      :type quit: str
      :param quit: Command to exit the conversation
      :rtype: str
      """

      # Handle the case where user input matches the quit command
      if user_input.lower() == quit:
          exit()
          return "Goodbye!"

      # Remove trailing punctuation
      while user_input and user_input[-1] in "!.":
          user_input = user_input[:-1]

      # Generate and return the response
      return self.respond(user_input)

pairs = [
    [r"Hi|Hello|hey",["Hello!What brings you here today?"]],
    [
        r"my name is (.*)",
        ["Hi! a Great to see you %1",]
    ],
    [
        r"Good Morning",
         ["Good Morning! I hope you’re having a good day",]
        ],
    [
        r"Good Evening",
         ["Good Evening! How was your day?",]
        ],
    [
        r"Good Afternoon",
         ["Good Aftermoon! How may I help you?",]
        ],
    [
        r"Good Night",
         ["Good Night!" ,]
        ],
    [
        r"What can you do with image recognition",["I can help identify objects, recognize text, detect faces, and more from images.",]
        ],

    [
        r"what is your name ?",
        ["I am an Image Recognising chatBot, Zylo",]
    ],
    [
        r"how are you ?",
        ["I'm doing good\nHow about You?",]
    ],
    [
        r"How do I upload an image for recognition?|How (.*) use (.*)",
        ["You can upload an image by clicking the upload button or dragging and dropping the image here.",]
    ],
    [
        r"what types of images can you recognize?|what kind of images can you recognise",
        ["I can recognize a wide range of objects, text, and faces in various types of images.",]
    ],
    [
        r"(.*) analyze (.*) real-time (.*)?|(.*) recognise (.*) real-time(.*)",
        ["Currently, I analyze images once they are uploaded. Real-time analysis may be available in future updates.",]
    ],
    [
        r"(.*) your age?",
        ["I'm a computer program dude\nAre you seriously asking me this?",]

    ],
    [
        r"(.*) not recognized(.*)|(.*) can't recognise(.*)|(.*) cannot recognise(.*)",
        ["Make sure the image is clear and the content is not obstructed. If the problem persists, try uploading a different image.",]

    ],
    [
        r"(.*)incorrect(.*) ?",
        ["I’ll try my best, but image recognition can sometimes be affected by image quality. If you have feedback, please let me know!",]
    ],
    [
        r"how (.*) work(.*)",
        ["Image recognition involves using machine learning algorithms to analyze and identify patterns within images. ",]
    ],
    [
        r"(.*)store(.*)images|(.*)keep(.*)images",
        ["Yes, I store the images you send me to further learn and give more accurate results."]
],
[
        r"(.*)multiple images(.*)",
        ["I can only work with one image at a time :("]
],
    [r"(.*)recognize(.*) famous (.*)?",["Sorry, currently I can't do that :( But I am working on it. ",]],

    [
        r"quit",
        ["BBye take care. See you soon :) ","It was nice talking to you. See you soon :)"]
],
]

def chatty(query):
    chat = Chat(pairs, reflections)
    return chat.converse(query)  # Simplified the return value

def should_exit_conversation(user_input):
    # List of goodbye phrases
    goodbye_phrases = ["quit", "bye", "goodbye", "see you later", "take care"]

    # Convert user input to lowercase for case-insensitive comparison
    user_input_lower = user_input.lower().strip()

    # Check if any of the goodbye phrases are in the user input
    if any(phrase in user_input_lower for phrase in goodbye_phrases):
        return True
    return False

while True:
    user_input = input("UserInput: ").strip()  # Get user input and remove leading/trailing spaces
    response = chatty(user_input)  # Get the chatbot's response
    print(f"Kylo: {response}")




    # Check if the user input is the quit command
    if should_exit_conversation(user_input):
        print("Kylo: Bye, take care. See you soon :)")
        break  # Exit the loop and end the conversation